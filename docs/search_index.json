[["index.html", "Desagregación de datos en encuestas de hogares: metodologías bayesianas para modelos de estimación en áreas pequeñas Agenda", " Desagregación de datos en encuestas de hogares: metodologías bayesianas para modelos de estimación en áreas pequeñas Andrés Gutiérrez1, Stalyn Guerrero2 2023-03-30 Agenda Experto Regional en Estadísticas Sociales - Comisión Económica para América Latina y el Caribe (CEPAL) - andres.gutierrez@cepal.org↩︎ Consultor - Comisión Económica para América Latina y el Caribe (CEPAL), guerrerostalyn@gmail.com↩︎ "],["material-del-curso.html", "Material del curso", " Material del curso En el siguiente enlace encontrará material bibliográfico complementario (Libros, presentaciones, casos de estudio y manuales de instalación) Descargar En el siguiente enlace encontrará las rutinas de R desarrolladas para el taller. Descargar "],["día-1---sesión-1--no-dejar-a-nadie-atrás---ods-y-la-agenda-2030.html", "Capítulo 1 Día 1 - Sesión 1- No dejar a nadie atrás - ODS y la Agenda 2030", " Capítulo 1 Día 1 - Sesión 1- No dejar a nadie atrás - ODS y la Agenda 2030 Ver presentación "],["día-1---sesión-2--censo-e-información-satelital.html", "Capítulo 2 Día 1 - Sesión 2- Censo e información satelital ", " Capítulo 2 Día 1 - Sesión 2- Censo e información satelital "],["uso-de-imágenes-satelitales-y-sae.html", "2.1 Uso de imágenes satelitales y SAE", " 2.1 Uso de imágenes satelitales y SAE Uno de los artículo pioneros de estimación de áreas pequeñas fue el artículo de Singh, R, et. al. (2002) el cual abordó la estimación del rendimiento de cultivos para los tehsil (unidad subadministrativa) del distriyo Rohtak district en Haryana (India). Las imágenes raster representan el mundo mediante un conjunto de celdas contiguas igualmente espaciadas conocidas como pixeles, estas imágenes tienen información como un sistema de información geográfico, Un sistema de referencia de coordenadas. Las imágenes almacenan un identificador, un valor en cada pixel (o un vector con diferentes valores) y cada celda tiene asociada una escala de colores. Las imágenes pueden obtenerse crudas y procesadas, estas primeras contienen solamente las capas de colores, las segundas contienen también valores que han sido procesados en cada celda (índices de vegetación, intensidad lumínica, tipo de vegetación). La información cruda puede utilizarse para entrenar características que se desean entrenar (carreteras, tipo de cultivo, bosque / no bosque), afortunadamente en Google Earth Engine encontramos muchos indicadores procesadas asociadas a un pixel. Estos indicadores pueden agregarse a nivel de un área geográfica. 2.1.1 Fuentes de datos de imágenes satelitales Algunas de las principales fuentes de imágenes satelitales son: http://earthexplorer.usgs.gov/ https://lpdaacsvc.cr.usgs.gov/appeears/ https://search.earthdata.nasa.gov/search https://scihub.coGTMnicus.eu/ https://aws.amazon.com/public-data-sets/landsat/ Sin embargo la mayor parte de estas fuentes están centralizadas en Google Earth Engine que permite buscar fuentes de datos provenientes de imágenes satelitales. GEE se puede manejar por medio de APIS en diferentes lenguajes de programación: Javascript (por defecto), Python y R (paquete rgee). "],["google-earth-eninge.html", "2.2 Google Earth Eninge", " 2.2 Google Earth Eninge Crear una cuenta en link, una vez que se ingrese a la cuenta puede buscarse los conjuntos de datos de interés: Una vez se busque el conjunto de datos se puede abrir un editor de código brindado por google en Javascript. Copiar y pegar la sintaxis que brinda el buscador de conjunto de datos para visualizar la imagen raster y disponer de sentencias que GTMmitan la obtención del conjunto de datos de interés posteriormente en R "],["instalación-de-rgee.html", "2.3 Instalación de rgee", " 2.3 Instalación de rgee Descargar e instalar anaconda o conda. (https://www.anaconda.com/products/individual) Abrir Anaconda prompt y configurar ambiente de trabajo (ambiente python rgee_py) con las siguientes sentencias: conda create -n rgee_py python=3.9 activate rgee_py pip install google-api-python-client pip install earthengine-api pip install numpy Listar los ambientes de Python disponibles en anaconda prompt conda env list Una vez identificado la ruta del ambiente ambiente rgee_py definirla en R (no se debe olvidar cambiar \\ por /). Instalar reticulate y rgee, cargar paquetes para procesamiento espacial y configurar el ambiente de trabajo como sigue: library(reticulate) # Conexión con Python library(rgee) # Conexión con Google Earth Engine library(sf) # Paquete para manejar datos geográficos library(dplyr) # Paquete para procesamiento de datos rgee_environment_dir = &quot;C://Users//sguerrero//Anaconda3//envs//rgee_py//python.exe&quot; # Configurar python (Algunas veces no es detectado y se debe reiniciar R) reticulate::use_python(rgee_environment_dir, required=T) rgee::ee_install_set_pyenv(py_path = rgee_environment_dir, py_env = &quot;rgee_py&quot;) Sys.setenv(RETICULATE_PYTHON = rgee_environment_dir) Sys.setenv(EARTHENGINE_PYTHON = rgee_environment_dir) Una vez configurado el ambiente puede iniciarlizarse una sesión de Google Earth Engine como sigue: rgee::ee_Initialize(drive = T) Notas: Se debe inicializar cada sesión con el comando rgee::ee_Initialize(drive = T). Los comandos de javascript que invoquen métodos con “.” se sustituyen por signo peso ($), por ejemplo: ee.ImageCollection().filterDate() # Javascript ee$ImageCollection()$filterDate() # R 2.3.1 Descargar información satelital Paso 1: disponer de los shapefile # shape &lt;- read_sf(&quot;Recursos/Día1/Sesion2/Shape/CHL_dam2.shp&quot;) shape &lt;- read_sf(&quot;Recursos/Día1/Sesion2/Shape/CHL_dam.shp&quot;) plot(shape[&quot;geometry&quot;]) Paso 2: Seleccionar el archivo de imágenes que desea procesar, para nuestro ejemplo luces nocturnas. luces &lt;- ee$ImageCollection(&quot;NOAA/DMSP-OLS/NIGHTTIME_LIGHTS&quot;) %&gt;% ee$ImageCollection$filterDate(&quot;2013-01-01&quot;, &quot;2014-01-01&quot;) %&gt;% ee$ImageCollection$map(function(x) x$select(&quot;stable_lights&quot;)) %&gt;% ee$ImageCollection$toBands() Paso 3: Descargar la información ## Tiempo 10 minutos shape_luces &lt;- map(unique(shape$dam), ~tryCatch(ee_extract( x = luces, y = shape[&quot;dam&quot;] %&gt;% filter(dam == .x), ee$Reducer$mean(), sf = FALSE ) %&gt;% mutate(dam = .x), error = function(e)data.frame(dam = .x))) shape_luces %&lt;&gt;% bind_rows() tba(shape_luces, cap = &quot;Promedio de luces nocturnasa&quot;) Tabla 2.1: Promedio de luces nocturnasa dam luces_nocturnas 05 0.2383 12 0.0731 11 0.0348 10 0.6748 15 0.4691 01 0.5006 02 0.6402 03 0.4240 04 1.2168 13 10.6203 14 0.9825 09 1.4667 08 2.6897 16 1.9556 07 1.8539 06 3.5849 Repetir la rutina para: Tipo de suelo: crops-coverfraction (Porcentaje de cubrimiento cultivos) y urban-coverfraction (Porcentaje de cobertura urbana) disponibles en https://develoGTMs.google.com/earth-engine/datasets/catalog/COGTMNICUS_Landcover_100m_Proba-V-C3_Global#description Tiempo de viaje al hospital o clínica más cercana (accessibility) y tiempo de viaje al hospital o clínica más cercana utilizando transporte no motorizado (accessibility_walking_only) información disponible en https://develoGTMs.google.com/earth-engine/datasets/catalog/Oxford_MAP_accessibility_to_healthcare_2019 Modificación humana, donde se consideran los asentamiento humano, la agricultura, el transporte, la minería y producción de energía e infraestructura eléctrica. En el siguiente link encuentra la información satelital https://develoGTMs.google.com/earth-engine/datasets/catalog/CSP_HM_GlobalHumanModification#description Paso 4 consolidar la información. dam luces_nocturnas cubrimiento_cultivo cubrimiento_urbano modificacion_humana accesibilidad_hospitales accesibilidad_hosp_caminado 05 0.2383 7.5529 2.1488 0.3131 101.1488 481.0220 12 0.0731 0.0014 0.0486 0.0419 557.4796 2410.1264 11 0.0348 0.4897 0.0455 0.0446 472.6701 1706.0858 10 0.6748 6.2825 0.4273 0.1569 182.5853 530.2074 15 0.4691 0.3049 0.3165 0.0790 129.5948 634.6007 01 0.5006 0.0630 0.1962 0.0576 149.3803 706.6626 02 0.6402 0.0106 0.1421 0.0655 239.0077 993.2293 03 0.4240 0.0887 0.2277 0.0702 261.4221 1033.4120 04 1.2168 1.2978 0.4280 0.1556 157.2359 558.3460 13 10.6203 11.2553 5.3412 0.3404 108.0762 288.9854 Los resultados se muestran en los siguientes mapas 2.3.2 Luces nocturnas 2.3.3 Cubrimiento cultivos 2.3.4 Cubrimiento urbanos 2.3.5 Modificación humana 2.3.6 Tiempo promedio al hospital 2.3.7 Tiempo promedio al hospital en vehiculo no motorizado "],["censos-de-población-y-vivienda.html", "2.4 Censos de población y vivienda", " 2.4 Censos de población y vivienda Es necesario definir las variables del país con los que se desea trabajar. De acuerdo a esto, como primer paso se debe tener acceso al censo del país, para ello puede acceder desde el siguiente enlace https://redatam.org/en/microdata en el cual dispondrá de un archivo .zip con los microdatos del país. Ahora bien, para leer el conjunto de datos, es necesario emplear la función redatam.open de la librería redatam, la cual depende directamente del diccionario censal del software REDATAM, este es un archivo con extensión dicx y que debe encontrarse en la carpeta sobre los datos que se están leyendo. Así, es como se crea un objeto dentro de R que hace la respectiva unión del diccionario con los microdatos de la base de datos censal. La siguiente sintaxis muestra la lectura del diccionario en R y los cálculos iniciales library(redatam) chile &lt;- redatam.open(&quot;CHL/2017/1.Ingreso/Data/cpv2017chl-cde.dicx&quot;) CONTEOS &lt;- redatam.query( CHL, &quot;freq REGION.IDREGION by AREAUR.URBRUR by PERSONA.P09 by PERSONA.ANEST by PERSONA.P08 by PERSONA.PBLOPER&quot;, tot.omit = FALSE ) # Eliminando totales de la tabla CONTEOS2 &lt;- CONTEOS %&gt;% filter_at(vars(matches(&quot;_label&quot;)), all_vars(. != &quot;__tot__&quot;)) Después de realizar algunas validaciones se estandarizan las variables como muestra el siguiente código. censo_mrp &lt;- CONTEOS2 %&gt;% transmute( dam = str_pad( string = IDREGION1_value, width = 2, pad = &quot;0&quot; ), area = case_when(URBRUR2_value == 1 ~ &quot;1&quot;, # 1 = Urbana TRUE ~ &quot;0&quot;), # 0 = Rural sexo = as.character(P085_value), edad = case_when( P093_value %in% 0:14 ~ &quot;1&quot;, # 5 a 14 P093_value %in% 15:29 ~ &quot;2&quot;, # 15 a 29 P093_value %in% 30:44 ~ &quot;3&quot;, # 30 a 44 P093_value %in% 45:64 ~ &quot;4&quot;, # 45 a 64 TRUE ~ &quot;5&quot; ), # 65 o mas anoest = case_when( P093_value &lt; 6~ &quot;98&quot;, #No aplica ANEST4_value == 99 ~ &quot;99&quot;, #NS/NR ANEST4_value == 0 ~ &quot;1&quot;, # Sin educacion ANEST4_value %in% c(1:6) ~ &quot;2&quot;, # 1 - 6 ANEST4_value %in% c(7:12) ~ &quot;3&quot;, # 7 - 12 ANEST4_value &gt; 12 ~ &quot;4&quot;, # mas de 12 TRUE ~ &quot;Error&quot; ), etnia = case_when( PBLOPER6_value == 1 ~ &quot;1&quot;, # Indigenas PBLOPER6_value == 2 ~ &quot;2&quot;, # Afro TRUE ~ &quot;3&quot; # Otro ), value ) %&gt;% group_by(dam, area, etnia, sexo, edad, anoest) %&gt;% summarise(n = sum(value)) A partir de la base estandarizada es posible construir algunas covariables para el departamento. censo_mrp &lt;- readRDS(&quot;Recursos/Día1/Sesion2/Data/censo_mrp_dam.rds&quot;) tasa_censo &lt;- model.matrix(dam ~ -1 +., data = censo_mrp %&gt;% select(-n)) %&gt;% data.frame() %&gt;% mutate(dam = censo_mrp$dam, n = censo_mrp$n) %&gt;% group_by(dam) %&gt;% summarise_all(~weighted.mean(x = .,w = n)) %&gt;% mutate(etnia1 = 1-etnia3-etnia2 ) %&gt;% select(-area0, -anoest98,-etnia3,-n) tba(tasa_censo) dam area1 etnia2 sexo2 edad2 edad3 edad4 edad5 anoest2 anoest3 anoest4 anoest99 etnia1 01 0.9380 0.0014 0.4924 0.2482 0.2309 0.2118 0.0755 0.1555 0.4839 0.2053 0.0294 0.2409 02 0.9411 0.0009 0.4815 0.2504 0.2418 0.2226 0.0748 0.1379 0.4793 0.2336 0.0364 0.1348 03 0.9104 0.0005 0.4953 0.2289 0.2075 0.2361 0.0982 0.1710 0.4933 0.1879 0.0183 0.1932 04 0.8119 0.0003 0.5132 0.2274 0.2003 0.2372 0.1182 0.1834 0.4781 0.1850 0.0279 0.0855 05 0.9101 0.0002 0.5153 0.2313 0.1970 0.2450 0.1361 0.1599 0.4705 0.2342 0.0293 0.0657 06 0.7439 0.0001 0.5039 0.2104 0.2083 0.2547 0.1191 0.2114 0.4856 0.1611 0.0235 0.0626 07 0.7322 0.0001 0.5104 0.2178 0.2012 0.2539 0.1230 0.2184 0.4842 0.1501 0.0246 0.0468 08 0.8858 0.0001 0.5178 0.2326 0.1978 0.2493 0.1176 0.1869 0.4591 0.2174 0.0210 0.1074 09 0.7089 0.0001 0.5141 0.2254 0.1973 0.2427 0.1258 0.2158 0.4653 0.1678 0.0282 0.3356 10 0.7361 0.0001 0.5060 0.2202 0.2145 0.2454 0.1121 0.2228 0.4724 0.1651 0.0263 0.2760 11 0.7958 0.0001 0.4800 0.2131 0.2336 0.2383 0.0901 0.1990 0.4715 0.1820 0.0208 0.2817 12 0.9190 0.0001 0.4881 0.2217 0.2277 0.2485 0.1164 0.1578 0.4841 0.2409 0.0201 0.2268 13 0.9630 0.0004 0.5132 0.2434 0.2186 0.2364 0.1079 0.1480 0.4468 0.2692 0.0281 0.0973 14 0.7166 0.0001 0.5093 0.2297 0.1934 0.2508 0.1258 0.2068 0.4695 0.1756 0.0319 0.2502 15 0.9167 0.0205 0.5020 0.2425 0.2098 0.2213 0.1087 0.1555 0.4840 0.2088 0.0323 0.3284 16 0.6943 0.0001 0.5161 0.2096 0.1947 0.2648 0.1355 0.2267 0.4748 0.1603 0.0236 0.0464 El indicador es posible definirlo a partir de una variable del censo, haciendo que el proceso seá hace más corto, para este caso es empleada la variable VIVIENDA.P03C, agregada por dam En el primer bloque que código usando la función redatam.query() se realiza el conteo de viviendas por el material del piso. Seguido de esto, eliminamos los registros que no son de interés, por ejemplo, el total en el dam o total nacional, los cuales se identifican dentro de la base con la etiqueta __tot__. El siguiente paso es contar el número de viviendas por dam que tienen los pisos de tierra en el censo (Pobx) y el total de viviendas que respondieron a la pregunta (PobT), para finalmente realizar el cociente de estas dos preguntas. CONTEOS &lt;- redatam.query(chile, &quot;freq REGION.IDREGION by VIVIENDA.P03C&quot;, tot.omit = FALSE) PISO &lt;- CONTEOS %&gt;% filter_at(vars(matches(&quot;_label&quot;)), all_vars(!. %in% c(&quot;__tot__&quot;,&quot;__mv__&quot;) )) tasa_piso &lt;- PISO %&gt;% mutate(Pobx = ifelse(P03C2_value %in% c(5), value, 0), PobT = value) %&gt;% group_by( depto = IDREGION1_value ) %&gt;% summarise(PobT = sum(PobT), Pobx = sum(Pobx)) %&gt;% transmute(depto, piso_tierra = Pobx/PobT) La tabla resultante se muestra a continuación. dam piso_tierra 05 0.0016 12 0.0005 11 0.0012 10 0.0005 15 0.0222 01 0.0179 02 0.0092 03 0.0132 04 0.0110 13 0.0009 14 0.0006 09 0.0029 08 0.0018 16 0.0047 07 0.0061 06 0.0038 El proceso se repite con otras preguntas del censo hasta consolidar la tabla siguiente. predictors_censo_dam &lt;- readRDS(&quot;Recursos/Día1/Sesion2/Data/predictors_censo_dam.rds&quot;) tba(predictors_censo_dam) dam area1 etnia2 sexo2 edad2 edad3 edad4 edad5 anoest2 anoest3 anoest4 anoest99 etnia1 piso_tierra material_paredes material_techo rezago_escolar alfabeta tasa_desocupacion 05 0.9101 0.0002 0.5153 0.2313 0.1970 0.2450 0.1361 0.1599 0.4705 0.2342 0.0293 0.0657 0.0016 0.3236 0.7653 0.3365 0.0479 0.0683 12 0.9190 0.0001 0.4881 0.2217 0.2277 0.2485 0.1164 0.1578 0.4841 0.2409 0.0201 0.2268 0.0005 0.2649 0.8785 0.3382 0.0431 0.0402 11 0.7958 0.0001 0.4800 0.2131 0.2336 0.2383 0.0901 0.1990 0.4715 0.1820 0.0208 0.2817 0.0012 0.3167 0.9398 0.2793 0.0795 0.0445 10 0.7361 0.0001 0.5060 0.2202 0.2145 0.2454 0.1121 0.2228 0.4724 0.1651 0.0263 0.2760 0.0005 0.3166 0.9082 0.2491 0.0823 0.0612 15 0.9167 0.0205 0.5020 0.2425 0.2098 0.2213 0.1087 0.1555 0.4840 0.2088 0.0323 0.3284 0.0222 0.2416 0.5142 0.3194 0.0485 0.0743 01 0.9380 0.0014 0.4924 0.2482 0.2309 0.2118 0.0755 0.1555 0.4839 0.2053 0.0294 0.2409 0.0179 0.2913 0.5745 0.3199 0.0394 0.0728 02 0.9411 0.0009 0.4815 0.2504 0.2418 0.2226 0.0748 0.1379 0.4793 0.2336 0.0364 0.1348 0.0092 0.2216 0.5673 0.3545 0.0342 0.0776 03 0.9104 0.0005 0.4953 0.2289 0.2075 0.2361 0.0982 0.1710 0.4933 0.1879 0.0183 0.1932 0.0132 0.3880 0.8275 0.2802 0.0561 0.0957 04 0.8119 0.0003 0.5132 0.2274 0.2003 0.2372 0.1182 0.1834 0.4781 0.1850 0.0279 0.0855 0.0110 0.3256 0.7896 0.2796 0.0624 0.0848 13 0.9630 0.0004 0.5132 0.2434 0.2186 0.2364 0.1079 0.1480 0.4468 0.2692 0.0281 0.0973 0.0009 0.1369 0.5678 0.3851 0.0429 0.0661 14 0.7166 0.0001 0.5093 0.2297 0.1934 0.2508 0.1258 0.2068 0.4695 0.1756 0.0319 0.2502 0.0006 0.3159 0.9292 0.2643 0.0866 0.0688 09 0.7089 0.0001 0.5141 0.2254 0.1973 0.2427 0.1258 0.2158 0.4653 0.1678 0.0282 0.3356 0.0029 0.3044 0.9193 0.2526 0.0896 0.0740 08 0.8858 0.0001 0.5178 0.2326 0.1978 0.2493 0.1176 0.1869 0.4591 0.2174 0.0210 0.1074 0.0018 0.2106 0.8356 0.3099 0.0689 0.0857 16 0.6943 0.0001 0.5161 0.2096 0.1947 0.2648 0.1355 0.2267 0.4748 0.1603 0.0236 0.0464 0.0047 0.2727 0.8988 0.2332 0.0936 0.0829 07 0.7322 0.0001 0.5104 0.2178 0.2012 0.2539 0.1230 0.2184 0.4842 0.1501 0.0246 0.0468 0.0061 0.2498 0.8574 0.2235 0.0917 0.0680 06 0.7439 0.0001 0.5039 0.2104 0.2083 0.2547 0.1191 0.2114 0.4856 0.1611 0.0235 0.0626 0.0038 0.2575 0.8052 0.2401 0.0763 0.0670 2.4.1 Mapas de las variables con información censal. temp2 &lt;- predictors_censo_dam %&gt;% select(-dam) %&gt;% names() temp2 &lt;- paste(&quot;Recursos/Día1/Sesion2/0Recursos/&quot;, temp2, &quot;.png&quot;) knitr::include_graphics(temp2) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
